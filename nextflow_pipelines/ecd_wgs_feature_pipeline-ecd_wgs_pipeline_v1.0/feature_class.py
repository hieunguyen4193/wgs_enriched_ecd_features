import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import os
from tqdm import tqdm
from itertools import combinations

class WGS_GW_Image_features:
    '''
    Class WGS_GW_Image_features stores the input .frag.tsv data frame. .frag.tsv dataframe is a fragment-wise
    tab-separated file with the following columns: chromosome, start position, end position, fragment length, read ID, QC score,
    forward nucleosome distance, reverse nucleosome distance, forward end motif, reverse end motif (4bp).
    From the input .frag.tsv data frame, the class generates the following features:
    1. FLEN: fragment length distribution vector 
    2. EM: end motif frequency vector
    3. NUC: nucleosome distance distribution vector
    4. image features generated by combining fragments' FLEN, EM, and NUC features.
    '''
    def __init__(self,
                 input_tsv,
                 outputdir):
        self.input_tsv = input_tsv
        self.sampleid = input_tsv.split("/")[-1].split(".")[0]
        print("reading in the input frag.tsv data")
        self.maindf = pd.read_csv(input_tsv, sep = "\t", header = None)
        self.maindf.columns = ["chr", 
                                "start", 
                                "end", 
                                "flen", 
                                "readID", 
                                "QC", 
                                "forward_NUC", "reverse_NUC", 
                                "forward_EM", "reverse_EM"
                                ]
        # convert all forward and reverse EMs to uppercase
        self.maindf["forward_EM"] = self.maindf["forward_EM"].apply(lambda x: x.upper())
        self.maindf["reverse_EM"] = self.maindf["reverse_EM"].apply(lambda x: x.upper())
        self.maindf["FLEN"] = self.maindf["flen"].abs()
        self.maindf = self.maindf[(self.maindf["FLEN"] >= 50) & (self.maindf["FLEN"] <= 350)]
        self.maindf = self.maindf[self.maindf["forward_EM"].str.contains("N") == False]
        self.maindf = self.maindf[self.maindf["reverse_EM"].str.contains("N") == False]
        self.outputdir = outputdir
        os.system(f"mkdir -p {self.outputdir}")
        
        # generate fulldf, to combine features to generate image features
        fulldf1 = pd.DataFrame(data = self.maindf.FLEN.values, columns= ["full_FLEN"])
        fulldf1["full_EM"] = self.maindf["forward_EM"].values
        fulldf1["forward_EM"] = self.maindf["forward_EM"].values
        fulldf1["reverse_EM"] = self.maindf["reverse_EM"].values

        fulldf1["full_NUC"] = self.maindf["forward_NUC"].values
        fulldf1["forward_NUC"] = self.maindf["forward_NUC"].values
        fulldf1["reverse_NUC"] = self.maindf["reverse_NUC"].values

        fulldf2 = pd.DataFrame(data = self.maindf.FLEN.values, columns= ["full_FLEN"])
        fulldf2["full_EM"] = self.maindf["reverse_EM"].values
        fulldf2["forward_EM"] = self.maindf["forward_EM"].values
        fulldf2["reverse_EM"] = self.maindf["reverse_EM"].values

        fulldf2["full_NUC"] = self.maindf["reverse_NUC"].values
        fulldf2["forward_NUC"] = self.maindf["forward_NUC"].values
        fulldf2["reverse_NUC"] = self.maindf["reverse_NUC"].values

        self.fulldf = pd.concat([fulldf1, fulldf2], axis = 0)   
        
    ##### generate FLEN feature    
    def generate_flen_feature(self, 
                              save_feature = True):
        flendf = self.maindf[["flen"]].copy()
        flendf["abs_flen"] = flendf["flen"].abs()
        if not flendf.empty:
            flen_count = flendf["abs_flen"].value_counts().reset_index()
            flen_count.columns = ["size", "count"]
            ##### keep only fragments that are between 50 and 350 bp
            flen_count = flen_count[(flen_count["size"] >= 50) & (flen_count["size"] <= 350)]
            flen_count["freq"] = flen_count["count"] / flen_count["count"].sum()
            flen_count = flen_count.sort_values("size")
            output_flendf = pd.DataFrame({"size": range(50, 351)})
            output_flendf = output_flendf.merge(flen_count, on="size", how="left").fillna(0)
            output_flendf = output_flendf[["size", "freq", "count"]]
            if save_feature:
                output_flendf.to_csv(os.path.join(self.outputdir, f"{self.sampleid}_GWfeature_FLEN.csv"), index=False)
            return output_flendf
    
    ##### generate EM feature
    def generate_em_feature(self, 
                            save_feature = True):
        emdf1 = self.maindf[["reverse_EM", "flen"]].copy() 
        emdf2 = self.maindf[["forward_EM", "flen"]].copy()
        emdf1 = emdf1[(emdf1["flen"] < 0)].drop(["flen"], axis = 1)
        emdf2 = emdf2[(emdf2["flen"] > 0)].drop(["flen"], axis = 1)

        emdf1.columns = ["motif"]
        emdf2.columns = ["motif"]
        
        emdf = pd.concat([emdf1, emdf2], axis = 0)
        emdf.columns = ["motif"]
        emdf = emdf[emdf["motif"].isna() == False]
        # remove any EMs that contain N, keep end motifs which are A, C, G, T
        emdf = emdf[emdf["motif"].str.contains("N") == False]
        output_emdf = emdf["motif"].value_counts().reset_index()
        if not output_emdf.empty:
            output_emdf.columns = ["motif", "count"]
            output_emdf = output_emdf[~output_emdf["motif"].str.contains("N")]
            output_emdf["freq"] = output_emdf["count"] / output_emdf["count"].sum()
            output_emdf = output_emdf[["motif", "freq"]]
            if save_feature:
                output_emdf.to_csv(os.path.join(self.outputdir, f"{self.sampleid}_GWfeature_EM.csv"), index=False)
            return output_emdf
        
    def generate_nuc_feature(self, 
                            save_feature = True):
        nucdf1 = pd.DataFrame(data = self.maindf["reverse_NUC"].values,
                     columns = ["feat"])
        nucdf2 = pd.DataFrame(data = self.maindf["forward_NUC"].values,
                     columns = ["feat"])
        nucdf = pd.concat([nucdf1, nucdf2], axis = 0)
        nucdf = nucdf[(nucdf["feat"] >= -300) & (nucdf["feat"] <= 300)]
        count_nucdf = nucdf.reset_index().groupby("feat")["index"].count().reset_index()
        count_nucdf["index"] = count_nucdf["index"].apply(lambda x: x/count_nucdf["index"].sum())
        count_nucdf.columns = ["dist", "freq"]
        
        output_nucdf = pd.DataFrame({"dist": range(-300, 301)})
        output_nucdf = output_nucdf.merge(count_nucdf, on="dist", how="left").fillna(0)
            
        if save_feature:
            output_nucdf.to_csv(os.path.join(self.outputdir, f"{self.sampleid}_GWfeature_ND.csv"), index=False)
        return output_nucdf
    
    def generate_all_image_features(self):
        all_features = self.fulldf.columns
        feature_combinations = list(combinations(all_features, 2))  # Generates combinations without replacement
        range_valuedf = {
            "NUC" : pd.DataFrame(
                    {
                        'NUC': range(-300, 301)
                    }
                ),
            "EM" : pd.DataFrame(
                    {
                        'EM': [f"{i}{j}{k}{l}" 
                            for i in ["A", "C", "G", "T"] 
                            for j in ["A", "C", "G", "T"] 
                            for k in ["A", "C", "G", "T"] 
                            for l in ["A", "C", "G", "T"]]
                    }
                ),
            "FLEN" : pd.DataFrame(
                    {
                        'FLEN': range(50, 351)
                    }
                )
        }
        for i in range(len(feature_combinations)):
            selected_features = list(feature_combinations[i])
            feature1 = selected_features[0]
            feature2 = selected_features[1]
            
            if (feature1.split("_")[1] != feature2.split("_")[1]):
                tmpdf = self.fulldf[selected_features].copy()
                countdf = tmpdf.reset_index() \
                                .groupby(selected_features)["index"] \
                                .count() \
                                .reset_index() \
                                .pivot_table(index=feature1, 
                                            columns=feature2, 
                                            values='index', 
                                            fill_value=0)

                countdf = countdf.reset_index().merge(range_valuedf[feature1.split("_")[1]], 
                                            left_on = feature1, 
                                            right_on = feature1.split("_")[1], 
                                            how = "outer")\
                    .fillna(0) \
                    .drop(feature1, axis = 1)
                countdf = countdf.rename(columns={feature1.split("_")[1]: feature1}).set_index(feature1)
                countdf = countdf/countdf.sum().sum()
                countdf.to_csv(os.path.join(self.outputdir, "_".join(selected_features)) + ".csv", index = True)

# EOF